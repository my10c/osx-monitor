#!/usr/bin/env python3
"""A python """
# BSD 3-Clause License
#
# Copyright (c) 2012, © Badassops LLC / Luc Suryo
# All rights reserved.
#
#*
#* File        :   check-user-osx
#*
#* Description    :   script to check if the given user is on console or how many are ssh into the mac
#*
#* Author    :    Luc Suryo <luc@badassops.com>
#*
#* Version    :    0.4
#*
#* Date        :    Sep 3, 2025
#*
#* History    :
#*        Date:          Author:        Info:
#*        Aug 17, 2012   LIS        First Release
#*        Dec 20, 2016   LIS        make sure it works with python3
#*        Mar 7, 2019    LIS        added colors :)
#*        Sep 3, 2025    LIS        text fixes
#*{% raw %}

import signal
import sys
import os
import time
import argparse
import socket
import subprocess
import io

from time import time, sleep, strftime

__progname__ = os.path.basename(__file__)
__author__      = 'Luc Suryo'
__copyright__   = 'Copyright 2012 - ' + strftime('%Y') + ' © Badassops LLC'
__license__     = 'License 3-Clause BSD, https://opensource.org/licenses/BSD-3-Clause ♥'
__version__     = '0.4'
__email__       = '<luc@badassops.com>'
__info__        = f'{__version__}\n{__copyright__}\nLicense {__license__}\n\nWritten by {__author__} {__email__}\n'
__description__ = 'Sscript to check if the given user is on console or how many are ssh into the mac'
__usage_txt__   = '<--ssh ssh count> <--user username>'
__host__        = socket.gethostname().split('.', 1)[0]

# colors
colorOFF    = '\033[0m'
colorRed    = '\033[1;31m'
colorGreen  = '\033[1;32m'
colorYellow = '\033[1;33m'
colorBlue   = '\033[1;34m'
colorPurple = '\033[1;35m'

# Defaults in seconds
DEFAULT_COUNT = 0

# Help messages
_HELP_SSH    = f'user logged via ssh count, default to {DEFAULT_COUNT}'
_HELP_USER   = 'username to be checked if logged via console'

# use variable

def signal_handler(signum, frame):
    """Signal/interrupts handler
        @param  signum  {int}       The interrupt ID according to signal.h.
        @param  frame   {string}    Memory frame where the interrupted was called.
    """
    DEBUG = 0
    print(f'\n\n{colorYellow}Process aborted due to received an interrupt: {signum} {colorOFF}')

    if DEBUG == 1:
        print (f'\n\n{colorYellow}Frame: {frame}{colorOFF}')
    sys.exit(128 + signum)

def process_check(given_options):
    """
        @param    given_options : dict with the below keys

        @param    ssh   : count users allowed logged via ssh
        @param    user  : user name logged via console
    """
    command = ['who']
    try:
        output = subprocess.run(command,  capture_output=True, text=True, check=True)
        data = output.stdout.strip().split('\n')
    except Exception as err:
        print(f'Unknown error: {err}')
        sys.exit(3)

    if given_options.ssh:
        cnt = 0
        user_list = []

        for line in data:
            if len(line.split()) == 5:
                user_list.append(line.split()[0])
                cnt += 1

        if cnt <= int(given_options.ssh):
            print(f'OK - {__host__} ssh logged count is {cnt} within given count check {given_options.ssh}, users: {','.join(user_list)}')
            sys.exit(0)
        print(f'CRITICAL - {__host__} ssh logged count is {cnt} above the given count check {given_options.ssh}, users: {','.join(user_list)}')
        sys.exit(2)

    # user was given since these are the only 2 options
    cnt = 0

    for line in data:
        if line.split()[0] == given_options.user and line.split()[1] == 'console':
            cnt += 1

        if cnt > 0:
            print(f'OK - {__host__} user {given_options.user} is logged via console')
            sys.exit(0)
        print(f'CRITICAL - {__host__} user {given_options.user} is not logged via console')
        sys.exit(2)

if __name__ == "__main__":
    # Install signal/interrupts handler, we capture only SIGHUP, SIGINT and TERM
    signal.signal(signal.SIGHUP, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Process giving arguments
    parser = argparse.ArgumentParser(usage = __usage_txt__, description = __description__,
          formatter_class = argparse.RawDescriptionHelpFormatter, conflict_handler='resolve')

    parser.add_argument('-v', '--version', action = 'version', version = __info__)

    group = parser.add_mutually_exclusive_group(required=True)

    group.add_argument('-s', '--ssh', action = 'store', dest = 'ssh', help = _HELP_SSH)

    group.add_argument('-u', '--user', action = 'store', dest = 'user', help = _HELP_USER)

    options = parser.parse_args()
    process_check(options)
#{%- endraw %}
